// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: real_time_message.proto

#ifndef PROTOBUF_INCLUDED_real_5ftime_5fmessage_2eproto
#define PROTOBUF_INCLUDED_real_5ftime_5fmessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "chat_message.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_real_5ftime_5fmessage_2eproto 

namespace protobuf_real_5ftime_5fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_real_5ftime_5fmessage_2eproto
namespace e8 {
class InvitationAcceptedMessage;
class InvitationAcceptedMessageDefaultTypeInternal;
extern InvitationAcceptedMessageDefaultTypeInternal _InvitationAcceptedMessage_default_instance_;
class InvitationReceivedMessage;
class InvitationReceivedMessageDefaultTypeInternal;
extern InvitationReceivedMessageDefaultTypeInternal _InvitationReceivedMessage_default_instance_;
class RealTimeMessage;
class RealTimeMessageDefaultTypeInternal;
extern RealTimeMessageDefaultTypeInternal _RealTimeMessage_default_instance_;
class RealTimeMessagenContent;
class RealTimeMessagenContentDefaultTypeInternal;
extern RealTimeMessagenContentDefaultTypeInternal _RealTimeMessagenContent_default_instance_;
class UnreadChatMessage;
class UnreadChatMessageDefaultTypeInternal;
extern UnreadChatMessageDefaultTypeInternal _UnreadChatMessage_default_instance_;
}  // namespace e8
namespace google {
namespace protobuf {
template<> ::e8::InvitationAcceptedMessage* Arena::CreateMaybeMessage<::e8::InvitationAcceptedMessage>(Arena*);
template<> ::e8::InvitationReceivedMessage* Arena::CreateMaybeMessage<::e8::InvitationReceivedMessage>(Arena*);
template<> ::e8::RealTimeMessage* Arena::CreateMaybeMessage<::e8::RealTimeMessage>(Arena*);
template<> ::e8::RealTimeMessagenContent* Arena::CreateMaybeMessage<::e8::RealTimeMessagenContent>(Arena*);
template<> ::e8::UnreadChatMessage* Arena::CreateMaybeMessage<::e8::UnreadChatMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace e8 {

// ===================================================================

class InvitationReceivedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:e8.InvitationReceivedMessage) */ {
 public:
  InvitationReceivedMessage();
  virtual ~InvitationReceivedMessage();

  InvitationReceivedMessage(const InvitationReceivedMessage& from);

  inline InvitationReceivedMessage& operator=(const InvitationReceivedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvitationReceivedMessage(InvitationReceivedMessage&& from) noexcept
    : InvitationReceivedMessage() {
    *this = ::std::move(from);
  }

  inline InvitationReceivedMessage& operator=(InvitationReceivedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationReceivedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvitationReceivedMessage* internal_default_instance() {
    return reinterpret_cast<const InvitationReceivedMessage*>(
               &_InvitationReceivedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(InvitationReceivedMessage* other);
  friend void swap(InvitationReceivedMessage& a, InvitationReceivedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvitationReceivedMessage* New() const final {
    return CreateMaybeMessage<InvitationReceivedMessage>(NULL);
  }

  InvitationReceivedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvitationReceivedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InvitationReceivedMessage& from);
  void MergeFrom(const InvitationReceivedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvitationReceivedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:e8.InvitationReceivedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_real_5ftime_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InvitationAcceptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:e8.InvitationAcceptedMessage) */ {
 public:
  InvitationAcceptedMessage();
  virtual ~InvitationAcceptedMessage();

  InvitationAcceptedMessage(const InvitationAcceptedMessage& from);

  inline InvitationAcceptedMessage& operator=(const InvitationAcceptedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvitationAcceptedMessage(InvitationAcceptedMessage&& from) noexcept
    : InvitationAcceptedMessage() {
    *this = ::std::move(from);
  }

  inline InvitationAcceptedMessage& operator=(InvitationAcceptedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationAcceptedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvitationAcceptedMessage* internal_default_instance() {
    return reinterpret_cast<const InvitationAcceptedMessage*>(
               &_InvitationAcceptedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(InvitationAcceptedMessage* other);
  friend void swap(InvitationAcceptedMessage& a, InvitationAcceptedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvitationAcceptedMessage* New() const final {
    return CreateMaybeMessage<InvitationAcceptedMessage>(NULL);
  }

  InvitationAcceptedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvitationAcceptedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InvitationAcceptedMessage& from);
  void MergeFrom(const InvitationAcceptedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvitationAcceptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:e8.InvitationAcceptedMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_real_5ftime_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnreadChatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:e8.UnreadChatMessage) */ {
 public:
  UnreadChatMessage();
  virtual ~UnreadChatMessage();

  UnreadChatMessage(const UnreadChatMessage& from);

  inline UnreadChatMessage& operator=(const UnreadChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnreadChatMessage(UnreadChatMessage&& from) noexcept
    : UnreadChatMessage() {
    *this = ::std::move(from);
  }

  inline UnreadChatMessage& operator=(UnreadChatMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnreadChatMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnreadChatMessage* internal_default_instance() {
    return reinterpret_cast<const UnreadChatMessage*>(
               &_UnreadChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UnreadChatMessage* other);
  friend void swap(UnreadChatMessage& a, UnreadChatMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnreadChatMessage* New() const final {
    return CreateMaybeMessage<UnreadChatMessage>(NULL);
  }

  UnreadChatMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnreadChatMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnreadChatMessage& from);
  void MergeFrom(const UnreadChatMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnreadChatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .e8.ChatMessageThread message_threads = 1;
  int message_threads_size() const;
  void clear_message_threads();
  static const int kMessageThreadsFieldNumber = 1;
  ::e8::ChatMessageThread* mutable_message_threads(int index);
  ::google::protobuf::RepeatedPtrField< ::e8::ChatMessageThread >*
      mutable_message_threads();
  const ::e8::ChatMessageThread& message_threads(int index) const;
  ::e8::ChatMessageThread* add_message_threads();
  const ::google::protobuf::RepeatedPtrField< ::e8::ChatMessageThread >&
      message_threads() const;

  // @@protoc_insertion_point(class_scope:e8.UnreadChatMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::e8::ChatMessageThread > message_threads_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_real_5ftime_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RealTimeMessagenContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:e8.RealTimeMessagenContent) */ {
 public:
  RealTimeMessagenContent();
  virtual ~RealTimeMessagenContent();

  RealTimeMessagenContent(const RealTimeMessagenContent& from);

  inline RealTimeMessagenContent& operator=(const RealTimeMessagenContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RealTimeMessagenContent(RealTimeMessagenContent&& from) noexcept
    : RealTimeMessagenContent() {
    *this = ::std::move(from);
  }

  inline RealTimeMessagenContent& operator=(RealTimeMessagenContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RealTimeMessagenContent& default_instance();

  enum NotificationContentCase {
    kInvitationReceived = 1,
    kInvitationAccepted = 2,
    kUnreadChat = 3,
    NOTIFICATION_CONTENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RealTimeMessagenContent* internal_default_instance() {
    return reinterpret_cast<const RealTimeMessagenContent*>(
               &_RealTimeMessagenContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RealTimeMessagenContent* other);
  friend void swap(RealTimeMessagenContent& a, RealTimeMessagenContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RealTimeMessagenContent* New() const final {
    return CreateMaybeMessage<RealTimeMessagenContent>(NULL);
  }

  RealTimeMessagenContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RealTimeMessagenContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RealTimeMessagenContent& from);
  void MergeFrom(const RealTimeMessagenContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RealTimeMessagenContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .e8.InvitationReceivedMessage invitation_received = 1;
  bool has_invitation_received() const;
  void clear_invitation_received();
  static const int kInvitationReceivedFieldNumber = 1;
  private:
  const ::e8::InvitationReceivedMessage& _internal_invitation_received() const;
  public:
  const ::e8::InvitationReceivedMessage& invitation_received() const;
  ::e8::InvitationReceivedMessage* release_invitation_received();
  ::e8::InvitationReceivedMessage* mutable_invitation_received();
  void set_allocated_invitation_received(::e8::InvitationReceivedMessage* invitation_received);

  // .e8.InvitationAcceptedMessage invitation_accepted = 2;
  bool has_invitation_accepted() const;
  void clear_invitation_accepted();
  static const int kInvitationAcceptedFieldNumber = 2;
  private:
  const ::e8::InvitationAcceptedMessage& _internal_invitation_accepted() const;
  public:
  const ::e8::InvitationAcceptedMessage& invitation_accepted() const;
  ::e8::InvitationAcceptedMessage* release_invitation_accepted();
  ::e8::InvitationAcceptedMessage* mutable_invitation_accepted();
  void set_allocated_invitation_accepted(::e8::InvitationAcceptedMessage* invitation_accepted);

  // .e8.UnreadChatMessage unread_chat = 3;
  bool has_unread_chat() const;
  void clear_unread_chat();
  static const int kUnreadChatFieldNumber = 3;
  private:
  const ::e8::UnreadChatMessage& _internal_unread_chat() const;
  public:
  const ::e8::UnreadChatMessage& unread_chat() const;
  ::e8::UnreadChatMessage* release_unread_chat();
  ::e8::UnreadChatMessage* mutable_unread_chat();
  void set_allocated_unread_chat(::e8::UnreadChatMessage* unread_chat);

  void clear_notification_content();
  NotificationContentCase notification_content_case() const;
  // @@protoc_insertion_point(class_scope:e8.RealTimeMessagenContent)
 private:
  void set_has_invitation_received();
  void set_has_invitation_accepted();
  void set_has_unread_chat();

  inline bool has_notification_content() const;
  inline void clear_has_notification_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union NotificationContentUnion {
    NotificationContentUnion() {}
    ::e8::InvitationReceivedMessage* invitation_received_;
    ::e8::InvitationAcceptedMessage* invitation_accepted_;
    ::e8::UnreadChatMessage* unread_chat_;
  } notification_content_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_real_5ftime_5fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RealTimeMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:e8.RealTimeMessage) */ {
 public:
  RealTimeMessage();
  virtual ~RealTimeMessage();

  RealTimeMessage(const RealTimeMessage& from);

  inline RealTimeMessage& operator=(const RealTimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RealTimeMessage(RealTimeMessage&& from) noexcept
    : RealTimeMessage() {
    *this = ::std::move(from);
  }

  inline RealTimeMessage& operator=(RealTimeMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RealTimeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RealTimeMessage* internal_default_instance() {
    return reinterpret_cast<const RealTimeMessage*>(
               &_RealTimeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RealTimeMessage* other);
  friend void swap(RealTimeMessage& a, RealTimeMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RealTimeMessage* New() const final {
    return CreateMaybeMessage<RealTimeMessage>(NULL);
  }

  RealTimeMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RealTimeMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RealTimeMessage& from);
  void MergeFrom(const RealTimeMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RealTimeMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .e8.RealTimeMessagenContent content = 4;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 4;
  private:
  const ::e8::RealTimeMessagenContent& _internal_content() const;
  public:
  const ::e8::RealTimeMessagenContent& content() const;
  ::e8::RealTimeMessagenContent* release_content();
  ::e8::RealTimeMessagenContent* mutable_content();
  void set_allocated_content(::e8::RealTimeMessagenContent* content);

  // int64 real_time_message_id = 1;
  void clear_real_time_message_id();
  static const int kRealTimeMessageIdFieldNumber = 1;
  ::google::protobuf::int64 real_time_message_id() const;
  void set_real_time_message_id(::google::protobuf::int64 value);

  // int64 created_at = 2;
  void clear_created_at();
  static const int kCreatedAtFieldNumber = 2;
  ::google::protobuf::int64 created_at() const;
  void set_created_at(::google::protobuf::int64 value);

  // int64 target_user_id = 3;
  void clear_target_user_id();
  static const int kTargetUserIdFieldNumber = 3;
  ::google::protobuf::int64 target_user_id() const;
  void set_target_user_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:e8.RealTimeMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::e8::RealTimeMessagenContent* content_;
  ::google::protobuf::int64 real_time_message_id_;
  ::google::protobuf::int64 created_at_;
  ::google::protobuf::int64 target_user_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_real_5ftime_5fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InvitationReceivedMessage

// -------------------------------------------------------------------

// InvitationAcceptedMessage

// -------------------------------------------------------------------

// UnreadChatMessage

// repeated .e8.ChatMessageThread message_threads = 1;
inline int UnreadChatMessage::message_threads_size() const {
  return message_threads_.size();
}
inline ::e8::ChatMessageThread* UnreadChatMessage::mutable_message_threads(int index) {
  // @@protoc_insertion_point(field_mutable:e8.UnreadChatMessage.message_threads)
  return message_threads_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::e8::ChatMessageThread >*
UnreadChatMessage::mutable_message_threads() {
  // @@protoc_insertion_point(field_mutable_list:e8.UnreadChatMessage.message_threads)
  return &message_threads_;
}
inline const ::e8::ChatMessageThread& UnreadChatMessage::message_threads(int index) const {
  // @@protoc_insertion_point(field_get:e8.UnreadChatMessage.message_threads)
  return message_threads_.Get(index);
}
inline ::e8::ChatMessageThread* UnreadChatMessage::add_message_threads() {
  // @@protoc_insertion_point(field_add:e8.UnreadChatMessage.message_threads)
  return message_threads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::e8::ChatMessageThread >&
UnreadChatMessage::message_threads() const {
  // @@protoc_insertion_point(field_list:e8.UnreadChatMessage.message_threads)
  return message_threads_;
}

// -------------------------------------------------------------------

// RealTimeMessagenContent

// .e8.InvitationReceivedMessage invitation_received = 1;
inline bool RealTimeMessagenContent::has_invitation_received() const {
  return notification_content_case() == kInvitationReceived;
}
inline void RealTimeMessagenContent::set_has_invitation_received() {
  _oneof_case_[0] = kInvitationReceived;
}
inline void RealTimeMessagenContent::clear_invitation_received() {
  if (has_invitation_received()) {
    delete notification_content_.invitation_received_;
    clear_has_notification_content();
  }
}
inline const ::e8::InvitationReceivedMessage& RealTimeMessagenContent::_internal_invitation_received() const {
  return *notification_content_.invitation_received_;
}
inline ::e8::InvitationReceivedMessage* RealTimeMessagenContent::release_invitation_received() {
  // @@protoc_insertion_point(field_release:e8.RealTimeMessagenContent.invitation_received)
  if (has_invitation_received()) {
    clear_has_notification_content();
      ::e8::InvitationReceivedMessage* temp = notification_content_.invitation_received_;
    notification_content_.invitation_received_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::e8::InvitationReceivedMessage& RealTimeMessagenContent::invitation_received() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessagenContent.invitation_received)
  return has_invitation_received()
      ? *notification_content_.invitation_received_
      : *reinterpret_cast< ::e8::InvitationReceivedMessage*>(&::e8::_InvitationReceivedMessage_default_instance_);
}
inline ::e8::InvitationReceivedMessage* RealTimeMessagenContent::mutable_invitation_received() {
  if (!has_invitation_received()) {
    clear_notification_content();
    set_has_invitation_received();
    notification_content_.invitation_received_ = CreateMaybeMessage< ::e8::InvitationReceivedMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:e8.RealTimeMessagenContent.invitation_received)
  return notification_content_.invitation_received_;
}

// .e8.InvitationAcceptedMessage invitation_accepted = 2;
inline bool RealTimeMessagenContent::has_invitation_accepted() const {
  return notification_content_case() == kInvitationAccepted;
}
inline void RealTimeMessagenContent::set_has_invitation_accepted() {
  _oneof_case_[0] = kInvitationAccepted;
}
inline void RealTimeMessagenContent::clear_invitation_accepted() {
  if (has_invitation_accepted()) {
    delete notification_content_.invitation_accepted_;
    clear_has_notification_content();
  }
}
inline const ::e8::InvitationAcceptedMessage& RealTimeMessagenContent::_internal_invitation_accepted() const {
  return *notification_content_.invitation_accepted_;
}
inline ::e8::InvitationAcceptedMessage* RealTimeMessagenContent::release_invitation_accepted() {
  // @@protoc_insertion_point(field_release:e8.RealTimeMessagenContent.invitation_accepted)
  if (has_invitation_accepted()) {
    clear_has_notification_content();
      ::e8::InvitationAcceptedMessage* temp = notification_content_.invitation_accepted_;
    notification_content_.invitation_accepted_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::e8::InvitationAcceptedMessage& RealTimeMessagenContent::invitation_accepted() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessagenContent.invitation_accepted)
  return has_invitation_accepted()
      ? *notification_content_.invitation_accepted_
      : *reinterpret_cast< ::e8::InvitationAcceptedMessage*>(&::e8::_InvitationAcceptedMessage_default_instance_);
}
inline ::e8::InvitationAcceptedMessage* RealTimeMessagenContent::mutable_invitation_accepted() {
  if (!has_invitation_accepted()) {
    clear_notification_content();
    set_has_invitation_accepted();
    notification_content_.invitation_accepted_ = CreateMaybeMessage< ::e8::InvitationAcceptedMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:e8.RealTimeMessagenContent.invitation_accepted)
  return notification_content_.invitation_accepted_;
}

// .e8.UnreadChatMessage unread_chat = 3;
inline bool RealTimeMessagenContent::has_unread_chat() const {
  return notification_content_case() == kUnreadChat;
}
inline void RealTimeMessagenContent::set_has_unread_chat() {
  _oneof_case_[0] = kUnreadChat;
}
inline void RealTimeMessagenContent::clear_unread_chat() {
  if (has_unread_chat()) {
    delete notification_content_.unread_chat_;
    clear_has_notification_content();
  }
}
inline const ::e8::UnreadChatMessage& RealTimeMessagenContent::_internal_unread_chat() const {
  return *notification_content_.unread_chat_;
}
inline ::e8::UnreadChatMessage* RealTimeMessagenContent::release_unread_chat() {
  // @@protoc_insertion_point(field_release:e8.RealTimeMessagenContent.unread_chat)
  if (has_unread_chat()) {
    clear_has_notification_content();
      ::e8::UnreadChatMessage* temp = notification_content_.unread_chat_;
    notification_content_.unread_chat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::e8::UnreadChatMessage& RealTimeMessagenContent::unread_chat() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessagenContent.unread_chat)
  return has_unread_chat()
      ? *notification_content_.unread_chat_
      : *reinterpret_cast< ::e8::UnreadChatMessage*>(&::e8::_UnreadChatMessage_default_instance_);
}
inline ::e8::UnreadChatMessage* RealTimeMessagenContent::mutable_unread_chat() {
  if (!has_unread_chat()) {
    clear_notification_content();
    set_has_unread_chat();
    notification_content_.unread_chat_ = CreateMaybeMessage< ::e8::UnreadChatMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:e8.RealTimeMessagenContent.unread_chat)
  return notification_content_.unread_chat_;
}

inline bool RealTimeMessagenContent::has_notification_content() const {
  return notification_content_case() != NOTIFICATION_CONTENT_NOT_SET;
}
inline void RealTimeMessagenContent::clear_has_notification_content() {
  _oneof_case_[0] = NOTIFICATION_CONTENT_NOT_SET;
}
inline RealTimeMessagenContent::NotificationContentCase RealTimeMessagenContent::notification_content_case() const {
  return RealTimeMessagenContent::NotificationContentCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RealTimeMessage

// int64 real_time_message_id = 1;
inline void RealTimeMessage::clear_real_time_message_id() {
  real_time_message_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RealTimeMessage::real_time_message_id() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessage.real_time_message_id)
  return real_time_message_id_;
}
inline void RealTimeMessage::set_real_time_message_id(::google::protobuf::int64 value) {
  
  real_time_message_id_ = value;
  // @@protoc_insertion_point(field_set:e8.RealTimeMessage.real_time_message_id)
}

// int64 created_at = 2;
inline void RealTimeMessage::clear_created_at() {
  created_at_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RealTimeMessage::created_at() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessage.created_at)
  return created_at_;
}
inline void RealTimeMessage::set_created_at(::google::protobuf::int64 value) {
  
  created_at_ = value;
  // @@protoc_insertion_point(field_set:e8.RealTimeMessage.created_at)
}

// int64 target_user_id = 3;
inline void RealTimeMessage::clear_target_user_id() {
  target_user_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RealTimeMessage::target_user_id() const {
  // @@protoc_insertion_point(field_get:e8.RealTimeMessage.target_user_id)
  return target_user_id_;
}
inline void RealTimeMessage::set_target_user_id(::google::protobuf::int64 value) {
  
  target_user_id_ = value;
  // @@protoc_insertion_point(field_set:e8.RealTimeMessage.target_user_id)
}

// .e8.RealTimeMessagenContent content = 4;
inline bool RealTimeMessage::has_content() const {
  return this != internal_default_instance() && content_ != NULL;
}
inline void RealTimeMessage::clear_content() {
  if (GetArenaNoVirtual() == NULL && content_ != NULL) {
    delete content_;
  }
  content_ = NULL;
}
inline const ::e8::RealTimeMessagenContent& RealTimeMessage::_internal_content() const {
  return *content_;
}
inline const ::e8::RealTimeMessagenContent& RealTimeMessage::content() const {
  const ::e8::RealTimeMessagenContent* p = content_;
  // @@protoc_insertion_point(field_get:e8.RealTimeMessage.content)
  return p != NULL ? *p : *reinterpret_cast<const ::e8::RealTimeMessagenContent*>(
      &::e8::_RealTimeMessagenContent_default_instance_);
}
inline ::e8::RealTimeMessagenContent* RealTimeMessage::release_content() {
  // @@protoc_insertion_point(field_release:e8.RealTimeMessage.content)
  
  ::e8::RealTimeMessagenContent* temp = content_;
  content_ = NULL;
  return temp;
}
inline ::e8::RealTimeMessagenContent* RealTimeMessage::mutable_content() {
  
  if (content_ == NULL) {
    auto* p = CreateMaybeMessage<::e8::RealTimeMessagenContent>(GetArenaNoVirtual());
    content_ = p;
  }
  // @@protoc_insertion_point(field_mutable:e8.RealTimeMessage.content)
  return content_;
}
inline void RealTimeMessage::set_allocated_content(::e8::RealTimeMessagenContent* content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete content_;
  }
  if (content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:e8.RealTimeMessage.content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace e8

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_real_5ftime_5fmessage_2eproto
